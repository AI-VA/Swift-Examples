import Foundation


// MARK: 1. Протоколы
// Это набор правил и требований, которые должны быть выполнены типом, который их реализует (классом, структурой или перечислением).
// Синтаксис протоколов напоминает класс, структуру или перечисление, за исключением одного ключевого слова — protocol, оно и определяет весь тип. Сначала пишем это ключевое слово, затем имя протокола (имя начинается с заглавной буквы, как для классов, структур, перечислений) и ставим фигурные скобки, которые обрамляют тело протокола:

// Абстракция - это когда ты работаешь с чем-то не на уровне конкретных классов или объектов, а на более высоком уровне абстракции. Вместо того, чтобы заботиться о деталях каждого класса, мы можем определить протокол, который объединит их всех в один тип. И когда мы используем этот протокол, мы уже не работаем с конкретными классами или объектами, а с их абстракциями. Таким образом, мы можем манипулировать большим количеством объектов, не заботясь об их конкретных реализациях. Понимаешь, это как играть в шахматы, мы не думаем о каждой фигуре отдельно, мы думаем о их общих характеристиках и пытаемся построить свою стратегию на основе этого.

// Протоколы позволяют создавать абстракции, которые упрощают работу с различными объектами. Они позволяют работать с объектами на более высоком уровне абстракции, не заботясь о их конкретных реализациях. Это делает код более гибким и масштабируемым, что особенно важно в больших проектах.

protocol SomeProtocol {
    // тело протокола
}

// Но некий класс не может наследовать больше одного класса, то есть должен быть один класс, от которого наследуется дочерний.
class SomeGodClass {
    var name = "God"
}

class SomeChildClass: SomeGodClass {
}

// Если вы попробуете наследоваться от двух классов, то.. Ну что же, дело ваше, только у вас ничего не выйдет.
class SomeGodClass {
    var name = "God"
}

class SomeAnotherClass {
    var name = "Another"
}

class SomeChildClass: SomeGodClass, SomeAnotherClass { // Error
}

// Это означает, что множественное наследование недопустимо. Если вам нужны свойство или метод из одного места, затем другое свойство из второго места, то классы тут не очень удобны. Как раз здесь нам придут на помощь протоколы, которые дают возможность множественного наследования.
protocol SomeFirstProtocol {}
protocol SomeSecondProtocol {}

class SomeClass: SomeFirstProtocol, SomeSecondProtoco1 {}


// Итак, у нас есть некий протокол - SomeProtocol и есть некий класс, который наследуется (реализуется) от протокола:
protocol SomeProtocol {
    // тело протокола
}

class SomeClass: SomeProtocol {
    // тело класса
}

// Из предыдущего вопроса понятно, что протокол — это набор правил и требований для типа, который его реализует, и говорить, что мы наследуемся от протокола, — неверно. Это от класса мы можем наследоваться, а протокол мы реализуем (используем описанные методы и свойства в каких-то классах, структурах и перечислениях).

// ! Обрати внимание!
// Протоколы выступают в качестве некоего документа, который говорит, что делать, но не говорит, как делать.
// Давайте создадим наш первый протокол, который будет иметь некое требуемое свойство. Чтобы создать свойство, нужно понять, что мы будем с ним делать:

// Так как наше свойство должно быть переменной (не константой), то ставим ключевое слово var.
// Придумаваем какое-то описательное имя свойства.
// Указываем, какого типа будет это свойство.
// Указываем, будет ли это свойство доступно для получения и/или записи. Для этого в фигурных скобках ставится одно или два ключевых слова: get — слово для получения данных, set — слово, указывающее на то, что свойство можно будет изменить.

// Синтаксис создания свойства:
var имя_Свойства: ТипСвойства { доступно_для_чтения(get) доступно_для_записи(set) }

// Ну что, давайте создадим наше первое свойство? Воспользуемся протоколом из предыдущего примера и создадим нашу переменную с именем someProperty, которая будет иметь тип String, а также будет доступна только для чтения, то есть в фигурных скобках у нас будет get.
protocol SomeProtocol {
    var someProperty: String { get }
}
class SomeClass: SomeProtocol { // Error
    // тело класса
}

// Как вы понимаете, наш класс не соответствует протоколу, который он должен реализовать. Это и есть требование к реализации, если бы у нас был бы другой класс, который реализует тот же протокол, то он бы тоже был бы вынужден соответствовать протоколу.
protocol SomeProtocol {
    var someProperty: String { get }
}

class SomeClass: SomeProtocol {
    var someProperty: String
    // тело класса
}

// Модернизируем наше свойство из примера выше так, чтобы оно могло быть доступным и изменяемым.
protocol SomeProtocol {
    var someProperty: String { get set}
}

class SomeClass: SomeProtocol {
    var someProperty: String
    // тело класса
}

// Да-да, всего лишь нужно добавить set, и теперь наше свойство стало доступным и изменяемым.
// Сейчас мы увидели два варианта, которыми могут обладать свойства, третьего не дано! Если вы попытаетесь установить только set, то компилятор выдаст ошибку.
protocol SomeProtocol {
    var someProperty: String { set } // Error
}
// Устанавливать только свойство для записи запрещено, и компилятор красочно об этом говорит.


// MARK: 2.
// Давайте рассмотрим такой пример: создадим протокол Dog, в котором у нас будет свойство paws, доступное только для чтения. Вот как будет выглядеть наш протокол:
protocol Dog {
    var paws: Int { get }
}

// Теперь создадим класс конкретной породы собак, например, Dachshund (такса). Этот класс должен реализовать протокол Dog, давайте сразу зададим данной породе количество лап — 4. Ага, не удивляйтесь, у собак 4 лапы :)
// И как мы знаем, количество лап увеличить невозможно, собаки рождаются с четырьмя.
protocol Dog {
    var paws: Int { get }
}

class Dachshund: Dog {
    var paws: Int = 4
}

// Теперь создаем экземпляр класса с именем knopka и выведем в консоль, сколько у кнопки лапок.
protocol Dog {
    var paws: Int { get }
}

class Dachshund: Dog {
    var paws: Int = 4
}

let knopka = Dachshund().paws
print(knopka)

// Все выглядит логично и понятно, ведь так? Но что будет, если мы захотим поменять количество лап у собаки? Так сказать, поиграть в Бога!
// Давайте это попробуем сделать. Сейчас наше свойство доступно только для чтения, не забывайте об этом. Возьмем наш экземпляр класса, получим доступ к количеству лап и введем свое значение. Напоминаем, наше свойство доступно для чтения, не для изменения! И что же мы увидим?
protocol Dog {
    var paws: Int { get }
}

class Dachshund: Dog {
    var paws: Int = 4
}

let knopka = Dachshund()
knopka.paws = 6
print(knopka.paws)

// Мы смогли изменить неизменяемое свойство, несмотря на то, что свойство, реализуемое из протокола, установлено только для чтения { get }, как такое вообще возможно!
// Что же это получается? Получается, нет разницы между get и set?
// На самом деле есть! Помните определение, что такое протоколы?
// Так как протокол — это всего лишь свод правил, которым должен удовлетворять некий тип, то и здесь, когда мы устанавливаем для свойства некие правила, сам язык нас «жестко» не привязывает к каким-то действиям, и поэтому компилятор, который призван нас оберегать от некоторого количества ошибок, не говорит нам, что мы сделали что-то не так. Он видит, что мы выполнили все требования, а дальше это не его дело, как вы там будете реализовывать то или иное действие.
// Чтобы явно указать в коде, что данное свойство не может быть изменено, у нас есть несколько путей:
// Мы можем создать экземпляр класса с указанием типа непосредственно самого протокола, так сказать, зайти с абстрактного уровня :)

// ! Обрати внимание!
// Протокол даёт возможность привести разные типы к одному общему.
// Когда мы явно указываем, что наш экземпляр класса будет иметь тип протокола (а протоколы – это другой уровень абстракции, мы говорили об этом ранее), то мы можем использовать наше свойство только для чтения. Если мы попытаемся записать туда новое значение, то компилятор скажет нам об этом:
protocol Dog {
    var paws: Int { get }
}

class Dachshund: Dog {
    var paws: Int = 4
}

let knopka: Dog = Dachshund() // Явно указываем, что наш экземпляр класса будет иметь тип протокола
knopka.paws = 6 // Error
print(knopka.paws)

// Как вы видите, теперь компилятор сам говорит о том, что данное свойство с количеством лап мы изменять не можем.
// Теперь давайте рассмотрим следующий вариант корректной работы свойства «только для чтения».
// Мы должны создать некую приватную переменную numberPaws, в которой будем хранить количество лап, инициализатор, в который передадим то самое количество лап и, конечное же, наше свойство, но теперь сделаем его вычисляемым, а не хранимым.

// ! Обрати внимание!
// Протоколы не обязывают указывать, какое свойство ты используешь: хранимое или вычисляемое.
// Пример корректной работы свойства «только для чтения».
protocol Dog {
    var paws: Int { get }
}

class Dachshund: Dog {
    private var numberPaws: Int
    
    var paws: Int {
        return numberPaws
    }
    
    init(p: Int) {
        numberPaws = p
    }
}

let knopka = Dachshund(p: 4)
knopka.paws = 6 // Error
print(knopka.paws)

// Как вы видите, свойство на чтение работает верно, не давая нам изменить количество лап у животного. Также вы можете явно указать непосредственно в самом классе, который реализует протокол, «защиту» от изменения.
// Давайте немного изменим предыдущий пример: уберем numberPaws, а paws оставим, при этом добавим private (set) в начале.
protocol Dog {
    var paws: Int { get }
}

class Dachshund: Dog {
    private (set) var paws: Int = 4 // Явно указываем непосредственно в классе «защиту» от изменения.
}

let knopka = Dachshund()
knopka.paws = 6 // Error
print(knopka.paws)

// Текст ошибки изменился, но суть осталась та же — мы не можем изменить количество лапок у животного. Если вы думаете, что просто убрав set, у вас получится то же самое, то вы ошибаетесь, компилятор вам об этом скажет.
// В качестве эксперимента оставим только private, а set уберем.
protocol Dog {
    var paws: Int { get }
}

class Dachshund: Dog {
    private var paws: Int = 4 // Error
}

let knopka = Dachshund()
knopka.paws = 6
print(knopka.paws)

// Свойство для чтения get мы разобрали. Теперь давайте детально посмотрим на связку {get set}. Первое, о чем нужно сказать, это не имеет значения, в каком порядке их записывать: {get set} или {set get}. Смысл остается неизменным.
// Давайте создадим дополнительные свойства в протоколе, это будут: вес пёсика типа Float и команды, которые он знает, — строковый массив. Эти два свойства будут обладать возможностями как на запись, так и на чтение. Единственное, для первого мы установим { get set }, а для второго — { set get } и посмотрим, что из этого получится.
protocol Dog {
    var paws: Int { get }
    var weight: Float { get set }
    var commands: [String] { set get }
}

// Используя предыдущий пример, создайте какую-либо породу собаки и опишите ее свойства, используя полученные знания.
// На изображении примера вы видите, что данные, которые должны быть неизменяемыми, такими и остаются. Мы не можем их поменять и компилятор нам об этом говорит.
protocol Dog {
  var paws: Int { get }
  var weight: Float { get set}
  var commands: [String] { set get }
}

class Doberman: Dog {
  private (set) var paws: Int = 4
  var weight: Float = 25.4
  var commands: [String] = ["Stand up", "lie down", "vote", "nearby", "enemy", "give a paw"]
 
}
 
class Mastiff: Dog {
  var paws: Int = 4
  var weight: Float = 27.5
  var commands: [String] = ["sit down", "lie down", "enemy", "give a paw"]
}
 
let tatarin = Doberman()
print(tatarin.paws)
print(tatarin.weight)
print(tatarin.commands)
 
//tatarin.paws = 6 // Error так как протокол реализует get
tatarin.weight = 44
tatarin.commands.append("sit down")
 
var bigBoy: Dog = Mastiff()
print(bigBoy.paws)
print(bigBoy.weight)
print(bigBoy.commands)
 
//bigBoy.paws = 6 // Error
bigBoy.weight = 60
bigBoy.commands.append("vote")

// По большему счету, когда мы использовали только один { get }, мы наблюдали такую картину, что данные можно без проблем изменять, если не прибегнуть к определенным возможностям, позволяющим использовать данное свойство только на запись.
// Тем самым просто { get } подразумевает использование и set, но явно этого не указывает. Вот как раз для того, чтобы мы могли добавить ограничения.
// Между { get } и { get set } есть небольшое отличие, и оно заключается в тех самых ограничениях, описанных нами ранее.
// Давайте рассмотрим, в чем оно проявляется на предыдущем примере, просто перед weight и commands поставив private (set)
protocol Dog {
    var paws: Int { get }
    private (set) var weight: Float { get set } // Error
    private (set) var commands: [String] { set get } // Error
}

// Как видите, такой фокус не пройдет, так как мы указали нашему свойству возможность изменяться.
// Вот и все отличие: { get } – имеет ограничения, которыми мы можем воспользоваться, а { get set } – не имеет и дает полный доступ к манипуляциям над ним.
// А теперь внимание, главный посыл: если вы явно не намерены использовать возможности ограничений { get }, то используйте в своих протоколах { set get }. Иначе это выглядит неуместным и бесполезным.
// Ну вот, теперь вы знаете тонкие моменты в работе с { set get }, и когда вам зададут такой «каверзный» вопрос на собеседовании, то вы со знанием дела ответите на него.
