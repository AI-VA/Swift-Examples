import Foundation


// MARK: 1. Конформить протокол (англ. conform — соответствовать) — соответствовать протоколу.

// Начнём с того, что ошибки в Swift отображаются значениями типов, которые соответствуют (конформят) протоколу Error. Вы можете использовать его, чтобы указать, что что-то пошло не так в вашем приложении.
// К примеру, если мы объявим перечисление, не указав его тип как Error, то увидим ошибку о том, что AutoError не конформит протокол Error, который в свою очередь является индикатором того, что перечисление может быть использовано для обработки ошибок.

enum AutoError {
    case isLost         // заблудился
    case lowBattery     // низкая батарея
    case brokeAutoDrive // проблемы с управлением машины
}

throw AutoError.isLost // Thrown expression type 'AutoError' does not conform to 'Error'


// Перечисления отлично подходят для группировки схожих между собой условий возникновения ошибок и соответствующих им значений, что позволяет получить дополнительную информацию о самой ошибке.

enum AutoError: Error { // Error это протокол
    case isLost         // заблудился
    case lowBattery     // низкая батарея
    case brokeAutoDrive // проблемы с управлением машины
}

// Генерация такой ошибки позволит нам узнать, что что-то пошло не так, и теперь программа не может продолжить свою работу. У протокола Error нет требований, и, следовательно, он не требует реализации, что также означает, что вам не нужно делать каждую ошибку перечислением. Например, вы также можете использовать другие типы, такие как структуры, чтобы указать, что что-то пошло не так. Структуры подходят меньше, но могут быть полезны, когда нужно добавить более обширные данные к ошибке.

struct MultipleParseLocationErrors: Error {
    let parsingErrors: [ParseLocationError]
    let isShownToUser: Bool
}

// Хотя ошибки обычно являются перечислениями, любой тип может соответствовать протоколу Error. Ошибки существуют, чтобы их можно было генерировать и обрабатывать. Например, если функция не может сохранить файл, она может сгенерировать ошибку с указанием причины, например, переполнение жесткого диска или отсутствие прав на запись на диск. Когда функция или метод может генерировать ошибку, Swift требует наличия ключевого слова throws за закрывающей скобкой.

// Этот код генерирует ошибку, указывая, что автопилот (или водитель, зависит от вашей программы) заблудился и ему нужна помощь!
throw AutoError.isLost

// Еще один специфический аспект обработки ошибок в Swift заключается в том, что функции не показывают, какие ошибки они могут генерировать. Функция, помеченная как throws, теоретически может не генерировать ошибки или семь миллионов различных ошибок, и это нельзя узнать, посмотрев на функцию. Отсутствие явного перечисления и обработки каждой ошибки дает вам гибкость, но существенным недостатком является то, что нельзя быстро узнать, какие ошибки может вызывать или распространять функция.

// Когда ошибка генерируется, то фрагмент кода, окружающий ошибку, должен обрабатывать её: исправить или информировать пользователя о ней. В Swift есть четыре способа обработки ошибок:
/*
* Передать ошибку из функции в код, который вызывает эту функцию
* Обработать ошибку, используя инструкцию do-catch
* Обработать ошибку, как значение опционала
* Поставить утверждение, что ошибка в данном случае исключена
* Давайте рассмотрим каждый способ!
*/


// MARK: 2. Передача ошибки с помощью генерирующей функции

// При передаче ошибки блок кода (функция, метод или инициализатор), ставший источником ошибки, самостоятельно не обрабатывает её, а передаёт выше в код, который вызвал данный блок кода. Для того чтобы указать блоку кода, что он должен передавать возникающие в нём ошибки, в реализации данного блока после списка параметров указывается ключевое слово throws.
// Чтобы указать, что функция может генерировать ошибку, нужно использовать ключевое слово throws в реализации функции после её параметров.
// Генерирующая функция — функция, которая отмечена throws.
// Давайте создадим генерирующую функцию, которая будет обрабатывать ошибки автопилота Теслы!
// Нам понадобится перечисление, которое мы использовали ранее:

enum AutoError: Error {
    case isLost         // заблудился
    case lowBattery     // низкая батарея
    case brokeAutoDrive // проблемы с управлением машины
}

// Создадим переменные ( они не относятся к enum)
var isLost: Bool = false
var lowBattery: Bool = false
var brokeAutoDrive: Bool = true

// И теперь создаем генерирующую функцию, внутри которой мы будем обрабатывать ошибки автопилота. Если заряд батареи низкий — выдаем соответствующую ошибку из enum, который мы объявляли выше. Так делаем с каждой переменной:

func autoDrive() throws {
if isLost { throw AutoError.isLost }
if lowBattery { throw AutoError.lowBattery }
if brokeAutoDrive { throw AutoError.brokeAutoDrive } // Соответствует протоколу Error
}

// Таким образом, генерирующая функция передает ошибки, которые возникают внутри неё, в область вызова этой функции. Важно понимать, что только генерирующая ошибку функция может передавать ошибки. Любые ошибки, сгенерированные внутри non-throwing* функции, должны быть обработаны внутри самой функции.
// Non-throwing функция — функция, не генерирующая ошибки.
// Как использовать генерирующую функцию, мы рассмотрим несколько позже, когда изучим все способы обработки ошибок и будем их комбинировать.


// MARK: 3. Обработка ошибок с использованием do-catch

// Для обработки ошибок используется do-catch. Синтаксис данного способа обработки ошибок следующий:

do {
    try имяВызываемогоБлока // вызов функции или метода, которые могут выбросить ошибку
} catch шаблон1 { // код...
} catch шаблон2 { // код...
}

// Если ошибка выдается в коде условия do, она соотносится с условием catch для определения того, кто именно сможет обработать ошибку.
// Оператор содержит блок do и произвольное количество блоков catch. В блоке do должен содержаться вызов функции или метода, которые могут выбросить ошибку.
// Вызов осуществляется с помощью оператора try. С помощью ключевого слова try мы можем обнаружить место генерации ошибки в коде. Если в результате вызова была выброшена ошибка, то данная ошибка сравнивается с шаблонами в блоках catch. Если в одном из них найдено совпадение, то выполняется код из данного блока.
// Рассмотрим, как бы это выглядело, если бы мы обрабатывали ошибки автопилота:

 enum AutoError: Error {
    case isLost         // заблудился
    case lowBattery     // низкая батарея
    case brokeAutoDrive // проблемы с управлением машины
}
 
var isLost: Bool = false
var lowBattery: Bool = false
var brokeAutoDrive: Bool = true
 
do {                                        // Проверяет переменные
    if isLost {
        throw AutoError.isLost             // Генерирует ошибку
    }
 
    if lowBattery {
        throw AutoError.lowBattery
    }
 
    if brokeAutoDrive {
        throw AutoError.brokeAutoDrive
    }
    
} catch AutoError.isLost {                  // Ловит и оповещает
    print("Вы заблудились! Включаю GPS")
} catch AutoError.lowBattery {
    print("Батарея садится! Ближайшая станция подзарядки через 1 км 300 м")
} catch AutoError.brokeAutoDrive {
    print("Режим автопилота поврежден. Переходим в режим ручного управления!")
}


// Вариант с do try
// Помните генерирующую функцию autoDrive()? Пришло время её использовать!
// В приведенном примере функция autoDrive() вызывается в выражении try, потому что она может сгенерировать ошибку.
// Если вы попытаетесь вызвать функцию, которая может выдать ошибку, вызову функции должно предшествовать ключевое слово try. Всё, что делает try, — это заставляет разработчика осознавать способность функции передавать ошибку.

func autoDrive() throws {
    if isLost {
        throw AutoError.isLost
    }
 
    if lowBattery {
        throw AutoError.lowBattery
    }
 
    if brokeAutoDrive {
        throw AutoError.brokeAutoDrive
    }
}

do {
    try autoDrive()            // try также проверяет но в этот раз функцию а не ifы
} catch AutoError.isLost {
    print("Вы заблудились! Включаю GPS")
} catch AutoError.lowBattery {
    print("Батарея садится! Ближайшая станция подзарядки через 1 км 300 м")
} catch AutoError.brokeAutoDrive {
    print("Режим автопилота поврежден. Переходим в режим ручного управления!")
}


// Вариант с do where
// Помимо всего прочего, вы можете использовать ключевое слово where в шаблонах условий:

do {
     try имяВызываемого Блока
   } catch шаблон 1 where условие { // код...
}

// В блоке catch мы можем «ловить» сгенерированную ошибку при определенном условии. Допустим, нам нужно отображать ошибку о том, что батарея садится, когда заряд батареи меньше 15. В таком случае следует использовать оператор where.

enum AutoError: Error {
    case lowBattery // низкий заряд батареи
}
 
var lowBattery: Bool = false
var batteryCharge = 51
 
do {
    if lowBattery {
        throw AutoError.lowBattery
    }
// Ловим сгенерированную ошибку, когда заряд батареи меньше 15
} catch AutoError.lowBattery where batteryCharge < 15  {
    print("Батарея садится! Ближайшая станция подзарядки через 300 м")
}
 

// MARK: 4. Преобразование ошибок в опциональные значения

// Как было сказано ранее, вы можете написать ключевое слово try  или его вариации — try? и try! перед той частью кода, которая вызывает функцию, метод или инициализатор, который может бросить ошибку.
// Если функция является функцией, генерирующей ошибку, но вас не интересуют причины сбоя, можно рассмотреть возможность преобразования результата такой функции в опционал с помощью ключевого слова try?. Если ошибка выбрасывается в процессе вычисления выражения try?, то значение выражения будет nil.
// Использование try? позволяет вам писать краткие структуры обработки ошибок, когда вы хотите обработать все ошибки одним и тем же способом.
// Например, если функция someThrowingFunction() выбросит ошибку, то в константе x окажется значение nil

func someThrowingFunction() throws -> Int {
// ...
}

let x = try? someThrowingFunction()
 
// Или если мы вызовем try? autoDrive(), то так же получим nil.
// Следующий код использует несколько способов извлечь данные или возвращает nil, если все они провалились.
// Если говорить о try!, то это та вещь, с которой обращаться нужно очень аккуратно. Если try! autoDrive() выбросит ошибку, то программа экстренно завершится! В Swift восклицательный знак всегда служит предупреждением. Он говорит разработчику: Swift больше не несёт ответственности, если что-то пойдет не так. Ключевое слово try! не выведет вас из обработки ошибок. Напротив, слишком частое использование может привести к неприятностям.
// Вы можете утверждать, что ошибки не произойдет, если использовать try!. В этом случае, например, когда вы выполняете принудительное извлечение, вы либо правы, либо у вас происходит сбой.
// Когда же стоит использовать это ключевое слово? Иногда вы знаете, что функция throw или методы не сгенерируют ошибку во время исполнения. В этих случаях, вы можете написать try! перед выражением для запрета передачи ошибки и завернуть вызов в утверждение того, что ошибка точно не будет сгенерирована. Если ошибка на самом деле сгенерирована, вы получите сообщение об ошибке исполнения.
