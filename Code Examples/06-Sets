import Foundation


// MARK: 1. Множества
// Это неупорядоченные коллекции уникальных значений. Вы можете использовать множества как альтернативы массиву, когда порядок для вас значения не имеет, или когда вам нужно быть уверенным в том, что значения внутри коллекции не повторяются.

// Синтаксис объявления пустого множества:
var numbers = Set<Int>()
// или:
var numbers: Set<Int> = []

// Пример ниже создаёт множество numbers для хранения Int.
var numbers: Set<Int> = [1, 3, 8, 2, 5, 4, 9, 24, 123, 8, 3, 6]

// Как видно, справа у нас порядок чисел после объявления множества не сохранился. Всё потому, что множество — неупорядоченная коллекция уникальных значений. Кстати, насчёт уникальных, два раза были объявлены числа 3, 8, а в итоговом варианте дубликатов у нас нет. Вот вам и существенное отличие от массивов и словарей!

// Переменная numbers объявлена как множество значений типа Int, которое записывается как Set. Так как это множество имеет определенный тип Int, то этому множеству позволено хранить только значения типа Int. Поэтому здесь мы инициализируем numbers 12 значениями типа Int, записанными в виде литерала массива.

// Кстати, можно было бы сделать numbers константой, но в дальнейшем это множество мы будем изменять, поэтому изначально оно было объявлено так.


// MARK: 2. Доступ и изменение
// Как и всегда, через точечный синтаксис мы можем обратиться к какому-то методу множества.
// Рассмотрим основные методы множества:

var numbers: Set<Int> = [1, 3, 8, 2, 5, 4, 9, 24, 123, 8, 3, 6]
// 1. Изначальная вместимость множества - 12 элементов
numbers.capacity // 12
 
// 2. Затем дубликаты были удалены (числа 3, 8). Итоговое количество элементов в множестве:
numbers.count // 10
 
// 3. Добавить новое значение в множество:
numbers.insert(12)
print(numbers) // [8, 9, 2, 123, 12, 5, 6, 4, 24, 3, 1] // 11
 
// 4. Проверить, хранит ли множество в себе какое-то значение:
numbers.contains(12) // true
 
// 5. Проверить, пустое ли множество
numbers.isEmpty // false
 
// 6. Удалить элемент из множества
numbers.remove(12)
print(numbers) // [8, 5, 3, 9, 24, 4, 123, 2, 6, 1]


// А что, если нам нужно вывести числа в консоль, да при этом по порядку? Множество же — это неупорядоченная коллекция!
// На помощь нам приходит метод sorted()

var numbers: Set<Int> = [1, 3, 8, 2, 5, 4, 9, 24, 123, 8, 3, 6]

for number in numbers.sorted() {
    print(number)
}


// MARK: 3. Базовые операции множеств

let setOne: Set<Int> = [1, 5, 8, 3, 4]
let setTwo: Set<Int> = [1, 3, 4, 5, 6, 7]
let setThree: Set<Int> = [10, 34, 32, 1, 88, 2, 0]

// Метод intersection(_:) вернет новое множество из одинаковых значений двух входных множеств
setOne.intersection(setTwo).sorted() // [1, 3, 4, 5]

// Метод symmetricDifference(_:) вернет новое множество из не одинаковых значений двух входных множеств
setOne.symmetricDifference(setTwo).sorted() // [6, 7, 8]

// Метод subtracting(_:) для создания множества со значениями, которые не принадлежат указанному множеству из двух входных;
setOne.subtracting(setThree).sorted() // [3, 4, 5, 8] первый set не содержит значений которые есть в третьем

// Метод union(_:) вернет новое множество, состоящее из всех значений обоих множеств;
setThree.union(setTwo).sorted() // [0, 1, 2, 3, 4, 5, 6, 7, 10, 32, 34, 88]


// MARK: 4. Взаимосвязь и равенство множества
// Иллюстрация ниже отображает три множества — a, b и c. Множество "a" является надмножеством множества "b", так как содержит все его элементы, соответственно множество "b" является подмножеством множества "a", опять-таки потому, что все его элементы находятся в "a". Множества "b" и "c" называются разделенными, так как у них нет общих элементов.

let mondayLessons: Set<String> = ["Математика", "Физика", "Английский язык", "Физическая культура", "Геометрия"]
let tuesdayLessons: Set<String> = ["Математика", "Литература", "Русский язык", "Физическая культура", "Физика"]
let wednesdayLessons: Set<String> = ["ОБЖ", "Обществознание", "Химия", "Биология"]

// Метод isSubset используется для определения того, все ли значения множества содержатся в указанном множестве.
mondayLessons.isSubset(of: tuesdayLessons) // false

// Метод isSuperset используется, чтобы определить содержит ли множество все значения указанного множества.
tuesdayLessons.isSuperset(of: wednesdayLessons) // false

// Метод isDisjoint используется для определения того, отсутствуют ли одинаковые значения в двух множествах или нет.
wednesdayLessons.isDisjoint(with: tuesdayLessons) // true

// Используя метод isSubset, мы проверили, все ли значения множества mondayLessons содержатся в множестве tuesdayLessons, и получили ложный ответ.
// Используя метод isSuperset, мы проверили, все ли значения множества wednesdayLessons содержатся в множестве tuesdayLessons,. и получили ложный ответ.
// Используя метод isDisjoint, мы проверили, отсутствуют ли одинаковые значения в двух множествах, или нет.
