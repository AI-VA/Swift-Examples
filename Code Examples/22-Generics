import Foundation


// MARK: 1. Дженерик (универсальный шаблон) — это универсальный механизм, позволяющий выполнять обработку данных, принимая в качестве параметра тип этих данных.

// Универсальные шаблоны позволяют создавать гибкие конструкции без привязки к конкретному типу данных. Вы лишь описываете требования и функциональные возможности, а Swift самостоятельно определяет, каким типам данных доступен разработанный функционал.
// Примером может служить тип данных Array (массив). Элементами массива могут выступать значения произвольных типов данных, и для этого разработчикам не требуется создавать отдельные типы массивов: Array<Int>, Array<String> и т. д. Для реализации коллекции использован универсальный шаблон, позволяющий при необходимости указать требования к типу данных.
// Swift, как вы помните, язык программирования со строгой типизацией. Если переменная объявлена как Int, то вы не можете присвоить ей значение типа String. Но представьте себе ситуацию, что у нас есть функция, которая складывает два целых числа. А что, если нам нужна функция, которая бы складывала два числа с плавающей точкой? Она ведь выглядела бы очень похожей! Единственное различие — тип переменных.

func addition(a: Double, b: Double) -> Double {
    return a + b
}
 
func addition<T: Numeric>(a: T, b: T) -> T { // Параметр типа <T: Numeric>
    return a + b
}
 
// Заполнитель имени Т — пример параметра типа. Параметры определяют и называют тип наполнителя, и пишутся сразу после имени функции между угловыми скобками <T>. Как только вы определили параметр типа, вы можете использовать его в качестве типа параметра функции или как возвращаемый функциональный тип. В каждом случае заполнитель типа отображается параметром типа, который заменяется на актуальное значение типа при вызове функции.

// Мы можем использовать несколько типов наполнителей: для этого пишем их между угловыми скобками через запятую.

func someFunc<T, E>(a: T, b: E) -> Void {
    /// some code
}
 
someFunc(a: "a", b: 5.2)
 
 
// Данная функция принимает несколько типов наполнителей, они представляют собой разные типы данных. Но вполне себе могут быть представлены и одним типом данных.
// T будет типа String, и Е будет типа String.

someFunc(a: "a", b: "б")

// Дженерик — очень крутой инструмент! При помощи него сокращается количество кода и улучшается логика. Будьте уверены, вы столкнетесь с ними не раз и сделаете свою жизнь проще =)


// MARK: 2. Универсальные типы

// В дополнение к универсальным функциям, Swift позволяет определять ваши универсальные типы: универсальные классы, структуры, перечисления.
// Создадим универсальный тип данных Stack (стек) — упорядоченную коллекцию элементов, подобную массиву, но со строгим набором доступных операций:
/*
* метод push(_:) служит для добавления элемента в конец коллекции; .
* метод pop() служит для возвращения элемента из конца коллекции с удалением его оттуда.
*/

// Никаких иных доступных операций для взаимодействия со своими элементами стек не поддерживает.
// Концепция стека используется классом UINavigationController для моделирования контроллеров видов в его иерархии навигации. Вы вызываете метод pushViewController(_:animated:) класса UINavigationController для добавления контроллера вида на стек навигации, а метод popViewControllerAnimated(_:) для удаления контроллера вида из стека навигации. Стек — полезная модель коллекции, когда вам нужен строгий принцип “последний на вход - первый на выход”.
// В первую очередь создадим неуниверсальную версию данного типа.

struct IntStack {
    var items = [Int]()
    
    mutating func push(_ item: Int) {
        items.append(item)
    }
    mutating func pop() -> Int {
        return items.removeLast()
    }
}
 
 
// Данный тип обеспечивает работу исключительно со значениями типа Int. В качестве хранилища элементов используется массив [Int]. И если нам нужно будет хранить элементы другого типа, то нужно будет либо создавать другой стек, либо преобразовывать этот к generic виду.
// Давайте реализуем универсальную версию типа, позволяющую работать с любыми однотипными элементами:

struct Stack<T> {
    var items = [T]()
    
    mutating func push(_ item: T) {
        items.append(item)
    }
    mutating func pop() -> T {
        return items.removeLast()
    }
}

// Эту тему вы проходили ранее, но напомню: ключевое слово mutating добавлено к определению метода, для того, чтобы изменить значения свойств.
// Как видно из примера, универсальная версия отличается от неуниверсальной только тем, что вместо указания конкретного типа данных задается заполнитель имени типа (Т). Создавая новую коллекцию типа Stack, в угловых скобках необходимо указать тип данных, после чего можно использовать описанные методы для модификации хранилища.

var stackOfStrings = Stack<String>() // Указываем тип элементов стека
stackOfStrings.push("one")
stackOfStrings.push("two")
let fromTheTop = stackOfStrings.pop()
 
// В коллекцию типа Stack<String> были добавлены два элемента и удален один. Удаляя последнее значение, он возвращает его и удаляет его из стека “two”.
// Мы можем доработать описанный тип данных так, чтобы при создании хранилища не было необходимости указывать тип элементов стека: достаточно будет лишь передать значения в качестве входного параметра в инициализатор типа.

struct Stack<T> {
    var items = [T]()
    
    init(){}
    init(_ elements: T...) {
        self.items = elements
    }
    mutating func push(_ item: T) {
        items.append(item)
    }
    mutating func pop() -> T {
        return items.removeLast()
    }
}

// Пустой инициализатор может быть полезен, когда у вас есть другие инициализаторы с аргументами, но вы также хотите иметь возможность создавать экземпляры структуры без передачи аргументов. Например, в данном случае у структуры Stack<T> есть ещё один инициализатор init(_ elements: T...), который принимает переменное количество элементов типа T для инициализации стека.
// Так как мы объявили собственный инициализатор, принимающий входной параметр, для сохранения функциональности пришлось описать пустой инициализатор.

var stackOfStrings = Stack(1, 2, 3)
stackOfStrings.push(4)
stackOfStrings.push(5)
let fromTheTop = stackOfStrings.pop() // 5

// Как было сказано ранее, теперь достаточно будет лишь передать значения в качестве входного параметра в инициализатор типа, а не указывать его, как это мы делали ранее.


// MARK: 3. Расширения универсального типа

// Swift позволяет расширять описанные универсальные типы. При этом имена заполнителей, использованные в описании типа, могут указывать и в расширении.
// Давайте расширим наш универсальный тип Stack, описанный ранее, добавив в него вычисляемое свойство, которое возвращает верхний элемент стека без его удаления.

extension Stack {
    var topItem: T? {
        return items.isEmpty ? nil : items[items.count - 1]
    }
}

stackOfStrings.topItem // 4
 
// Свойство topItem задействует заполнитель типа Т для указания типа свойства. Это свойство является опционалом, поскольку значение в стеке может отсутствовать: тогда нам вернется nil.
