import Foundation


// MARK: 1. Массивы
// Например, объявим массив фруктов, внутри которого будут храниться их названия. В данном случае, как вы помните, можно было явно не указывать тип данных для переменной/константы. Swift сделал бы эту работу за нас.
let fruits: [String] = ["apple", "banana", "orange"]
// Или создадим массив чисел:
let numbers = [1, 2, 3]

// В примерах выше мы сразу инициализировали наш массив, то есть определяли начальное значение. Мы также можем определить пустой массив, причем двумя способами:
var numbers = [Int]()
// или так
var numbers2: [Int] = []
// В массиве на данный момент ноль элементов.

// Давайте на предыдущих примерах с фруктами и числами рассмотрим изменение и получение элементов массива.
var fruits: [String] = ["apple", "banana", "orange"]
fruits[0] // apple
fruits[1] // banana
fruits[2] // orange
 
var numbers = [1, 2, 3]
numbers[0] // 1
numbers[1] // 2
numbers[2] // 3
// Как вы видите, для того, чтобы обратиться к элементу массива, нужно после названия массива в фигурных скобках указать его индекс.


// MARK: 2. Изменение элементов массива
// Для того, чтобы изменить какой-то элемент массива, нужно обратиться к элементу по индексу и присвоить ему новое значение:

// 1
var fruits = ["apple", "banana", "orange"]
fruits[0] = "peach"
print(fruits) // ["peach", "banana", "orange"]
 
// Мы можем добавить элементы массива сразу пачкой, используя диапазон значения.
var fruits = ["apple", "banana", "orange"]
// Заменим текущие элементы массива под индексами от 1 до 2
fruits[1...2] = ["nectarine", "pear"] // ["apple", "nectarine", "pear"]


// MARK: 3. Добавление элементов в массив
// Для добавления элемента в массив необходимо использовать метод append(). Внутри скобок указывается элемент, который вы хотите добавить. Элемент добавится в конец массива.
var fruits: [String] = ["apple", "banana", "orange"]
fruits.append("kiwi") // ["apple", "banana", "orange", "kiwi"]

// Другой метод — insert(), управляет вставкой элемента в определённое место массива:
// Сначала указываем элемент, который необходимо добавить, а затем — номер позиции (индекса). Результат:
var fruits: [String] = ["apple", "banana", "orange"]
fruits.insert("kiwi", at: 3)

// Или же можно использовать += для добавления массива элементов в массив.
fruits += ["pear", "pineapple"] // ["apple", "nectarine", "pear", "kiwi", "pear", "pineapple"]


// MARK: 3. Удаление элементов
// Если вы напишете имя массива, а затем используете точечный индекс для того, чтобы обратиться к какому-то его методу, то увидите массу вариантов.
var fruits: [String] = ["apple", "nectarine", "pear", "kiwi", "pear", "pineapple"]
 
fruits.removeLast()  // удаляет последний элемент
fruits.removeFirst() // удаляет первый элемент
fruits.remove(at: 1) // удаляем элемент по определенному индексу
fruits
fruits.removeAll()   // удаляет все элементы

// А ещё мы можем использовать методы dropLast(), dropFirst(), которые удаляют последний и первый элемент соответственно.
// ["nectarine", "kiwi", "pear"]
print(fruits.dropLast()) // ["nectarine", "kiwi"]
print(fruits.dropFirst()) // ["kiwi", "pear"]
print(fruits) // ["nectarine", "kiwi", "pear"] ??????????
 
// удалит последние два элемента
fruits = fruits.dropLast(2) // ["nectarine"]
// удалит последний элемент
fruits = fruits.dropLast() // []

// В чем же разница dropLast и dropFirst от removeLast и removeFirst? Обратимся к официальной документации Apple:
// removeFirst() и removeLast() возвращают удаленный элемент, при этом они модифицируют исходный массив.
// dropFirst() и dropLast(), возвращают уже модифицированный массив, но при этом не изменяют исходный.

// Если говорить о методах removeFirst(Int) и removeLast(Int), где мы указываем, какое количество элементов хотим удалить, нам возвращаются уже не удалённые элементы массива, а новый массив. При этом исходный массив всё так же изменяется.
// Будем рассматривать методы для удаления элементов из конца, так как они работают аналогично методам, удаляющим элементы из начала.

var array: Array<Float> = [3.14, 2321.1, 1311.1, 11.1, 1765.2, 8765.3, 3231.1, 36873.893222, 9876.01, 2.0, 7123.998171]
 
array.removeLast(2)  // [3.14, 2321.1, 1311.1, 11.1, 1765.2, 8765.3, 3231.1, 36873.89, 9876.01] // возвращает новый массив модифицируя исходный
array.removeLast()   // 9876.01                                                                 // возвращает удалённый элемент
print(array)
// [3.14, 2321.1, 1311.1, 11.1, 1765.2, 8765.3, 3231.1, 36873.895]                              // изменяет исходный массив


var array2: Array<Float> = [3.14, 2321.1, 1311.1, 11.1, 1765.2, 8765.3, 3231.1, 36873.893222, 9876.01, 2.0, 7123.998171]

array2.dropLast()     // [3.14, 2321.1, 1311.1, 11.1, 1765.2, 8765.3, 3231.1, 36873.895, 9876.01, 2.0] // возвращает модифицированный массив, не изменяет исходный
array2.dropLast(2)    // [3.14, 2321.1, 1311.1, 11.1, 1765.2, 8765.3, 3231.1, 36873.895, 9876.01]
print(array2)
// [3.14, 2321.1, 1311.1, 11.1, 1765.2, 8765.3, 3231.1, 36873.895, 9876.01, 2.0, 7123.998]      // не изменяет исходный массив


// MARK: 4. Итерация по массиву
// Перед тем, как мы рассмотрим тему итерации по массиву, давайте узнаем, как определить количество элементов в массиве. В дальнейшем нам это понадобится. А на практике, будьте уверены, вы это будете использовать не так уж и редко!
// Для того, чтобы узнать количество элементов в массиве, необходимо воспользоваться свойством count
var restoraunts = ["Grizza", "Токио сити", "Пряности и сладости", "Kitchenezz"]
restoraunts.count // 4


// С помощью цикла for мы можем перебрать элементы массива. Есть несколько способов сделать это:
// Первый пример самый тривиальный. Проходим по элементам массива и выводим каждый из них в консоль. number в данном случае — элемент массива. Сначала нулевой (по индексу), потом второй, третий и так далее до конца.
var numbers: [Int] = [1, 2, 3, 4, 5, 6]
 
for number in numbers {
    print(number) // 1, 2, 3, 4, 5, 6
}
 
// Второй пример демонстрирует нам перебор массива по индексу. Для этого нам недостаточно будет просто указать массив после in. Нужно уже указывать числовые значения, чтобы он их брал. То есть здесь уместно и необходимо использовать диапазон значений массива. Иначе, если мы укажем просто for index in array, index, — это будет какой-то элемент массива, а не число, которое впоследствии мы будем использовать в качестве индекса в array[index].
var array = ["элемент1", "элемент2", "элемент3"]
 
for index in 0..<array.count {
    print(array[index]) // элемент1, элемент2, элемент3
}
 
// 3 метод forEach()
numbers.forEach( {print($0)} ) // 1, 2, 3, 4, 5, 6
// Третий пример говорит нам о том, что вместо применения цикла также можно использовать метод forEach(), который перебирает все элементы. В качестве параметра этот метод принимает функцию, которая производит действия над текущим перебираемым элементом.

//Разница ещё состоит в том, что, используя forEach(), нельзя пропустить какие-либо элементы — вы не можете выйти из цикла частично, не обработав остальные элементы. Это помогает людям, читающим ваш код, понять ваше намерение: вы хотите действовать по всем пунктам и не останавливаетесь на середине.

//Если остановиться на forEach ещё чуть подробнее, то важно отметить эквивалентность двух записей. Возможно, не всем очевидно, что представляет из себя $0, поэтому для начала рассмотрим аналогичный пример, но с другой, более длинной записью.
var array = ["элемент1", "элемент2", "элемент3"]
 
array.forEach { (element) in
    print(element)
}
//элемент1
//элемент2
//элемент3

// Внутри замыкания, которое было изучено вами в одном из модулей, вы можете ссылаться на эти параметры, используя $0 для первого параметра, $1 — для второго и так далее. Таким образом, предыдущий фрагмент кода также можно записать, как показано ниже:

array.forEach {
    print($0)
}
//элемент1
//элемент2
//элемент3


// Давайте напишем код, который будет удалять определённые ненужные файлы:
["file_one.txt", "file_two.txt"].forEach { path in deleteFile(path: path)
}
func deleteFile(path: String) {
// Удаляем файл ....
}
 
// С forEach у вас есть прекрасный способ для вызова функции. Фактически, если функция принимает только аргумент и ничего не возвращает, можно вместо этого напрямую передать её (функцию) forEach. Обратите внимание, что в этом листинге фигурные скобки {} заменены круглыми (), потому что вы передаёте функцию напрямую.
["file_one.txt", "file_two.txt"].forEach(deleteFile)


// Рассмотрим другой пример:
// У нас есть массив shoppingList, который хранит в себе продукты, которые нам необходимо приобрести в магазине. Для того, чтобы вывести список в консоль, необходимо использовать цикл for in. С помощью метода enumerated() можно одновременно получить индекс и значение элемента. Он возвращает кортеж для каждого элемента массива, собрав вместе индекс и значение для этого элемента.
let shoppingList = ["milk", "bread", "water", "meat", "candy"]
 
for (index, value) in shoppingList.enumerated() {
  print("\(index + 1): \(value)")
}
 
//1: milk
//2: bread
//3: water
//4: meat
//5: candy
// С помощью метода enumerated() мы одновременно получили индекс и значение элемента, а затем вывели их в консоль.


// MARK: 5. Многомерные массивы
// Мы можем создавать более сложные массивы, которые в качестве элементов будут включать в себя другие массивы.
let numbers = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
numbers[0]        // первый элемент — сам первый массив [1, 2, 3]
numbers[1]
numbers[2]
numbers[0][0]     // первый элемент массива [1, 2, 3]
numbers[1][0]
numbers[2][0]

// Перебор многомерного массива через цикл
for row in numbers {
    for cell in row {
        print(cell)
    }
}

//1
//2
//3
//4
//5
//6
//7
//8
//9
