import Foundation


// MARK: 1. map
// Функция map возвращает массив, содержащий результаты применения заданного действия к каждому элементу.

// Предположим, нам нужно возвести числа из массива в квадрат. Конечно, для этого мы можем использовать наш любимый цикл for-in:
let values = [2.0, 4.0, 5.0, 7.0]
var squares: [Double] = []
for value in values {
    squares.append(value * value)
}

// Какой-то код громоздкий получился, вам не кажется? Если вам так ещё не кажется, то предлагаем взглянуть на этот код:
let values = [2.0, 4.0, 5.0, 7.0]
let squares = values.map( {$0 * $0} )

// Функция map содержит в качестве единственного аргумента замыкание (closure). Именно его она вызывает, когда мы бежим по коллекции и применяем действие к каждому элементу. Это замыкание обрабатывает каждый элемент коллекции и возвращает результат. Функция map в свою очередь возвращает этот результат обратно в массив. Если написать предыдущий код развернуто, то он должен выглядеть так:

values.map({ (value: Double) -> Double in
    return value * value
})

// Предлагаем постепенно его сокращать и в итоге привести к первоначальному виду, который мы использовали. Тем более, что так даже понятнее будет! Подумайте, что уже можно отбросить, что нам не нужно? Верно — тип! Замыкание имеет всего один аргумент (value: Double) и возвращает Double. Swift может легко использовать type inferrence, чтобы угадать этот тип. Ко всему прочему, нам не нужны скобки ( ), так как map имеет всего лишь один аргумент — замыкание. Поэтому мы легко запишем выражение в одну строку.

values.map { value in return value * value }
// Уже лучше! Но всё равно недостаточно коротко :) Для начала, мы можем убрать return.

values.map { value in value * value }
// Мы у цели! Подумайте, что ещё можно убрать? У нас везде повторяется value. Ключевое слово in отделяет аргументы замыкания от его тела (описания действия). Если вы хотите ещё немного упростить выражение, можно использовать нумерованное сжатие имени аргумента:

let squares = values.map {$0 * $0}
// Мы вернулись к тому, что у нас было, и даже укоротили этот вариант, убрав скобки ( ). Метод map не ограничен в использовании только массивами, а может быть использован в любых других коллекциях, например Dictionary или Set. Результатом же будет всегда Array.


// MARK: 2. filter
// Метод filter фильтрует данные в зависимости от того, какое замыкание вы передаёте. filter передаёт каждый элемент в функцию замыкания и ожидает логический тип в ответ. Он возвращает новую коллекцию, за исключением того, что он сохраняет элементы, из которых вы возвращаете значение true, в переданном замыкании.
// Другими словами, метод filter создает новый массив с отфильтрованными элементами, то есть из массива удалены так называемые «нежелательные» элементы. Функция, передаваемая как аргумент, возвращает false, если элемент «нежелательный».

// Используйте filter чтобы отфильтровать коллекцию и получить массив Array, в который входят только элементы удовлетворяющие условию
// Рассмотрим пример. В данном случае мы создали массив из имен, а далее, при помощи фильтра, нашли элементы массива, количество букв которых строго меньше пяти, и присвоили этот модифицированный массив константе shortNames.

let names = ["Alex", "Karlson", "Jim", "Karl", "Kevin"]
let shortNames = names.filter { $0.count < 5 }
print(shortNames) // "["Alex", "Jim", "Karl"]

// Или, предположим, нам необходимо выбрать из массива разрешенный возраст.
let ages = [1, 2, 3, 4, 5, 6, 14, 17, 18, 21, 23]
let allowedAges = ages.filter { $0 >= 18}
print(allowedAges) // [18, 21, 23]

// Фильтр отлично с этим справится!
// А вот в этом примере, используя фильтр, мы оставим только чётные числа.
let digits = [1, 4, 10, 15]
let even = digits.filter { $0 % 2 == 0 }
print(csv) // [4, 10]


// Пример
struct Product {
   let id: String
   let name: String
   let productDescription: String
   let category: String
   let price: Double
   let companyId: Int
}

// Массив элементов структуры, которые мы получаем с сервера
let products = [
   Product(id: "4d1d295e-1932-4234-34cd-db32422ds", name: "Цезарь", productDescription: "300 гр", category: "Салаты", price: 320, companyId: 3456121),
   Product(id: "80dosp23-4263-992d-ddle-njpoi2mlw", name: "Борщ", productDescription: "400 гр", category: "Горячее", price: 200, companyId: 3456121),
   Product(id: "37289jso-los1-ds13-3321-dspqqwe23", name: "Устрицы", productDescription: "200 гр", category: "Деликатесы", price: 570, companyId: 3456121),
   Product(id: "skli3112-123a-as31-34cd-poin2koqs", name: "Коктейль", productDescription: "250 мл", category: "Напитки", price: 320, companyId: 3456121)
]

// Массив элементов, который ранее был сохранен в БД
var productsDatabase = [
   Product(id: "4d1d295e-1932-4234-34cd-db32422ds", name: "Цезарь", productDescription: "300 гр", category: "Салаты", price: 320, companyId: 3456121),
   Product(id: "80dosp23-4263-992d-ddle-njpoi2mlw", name: "Борщ", productDescription: "400 гр", category: "Горячее", price: 200, companyId: 3456121),
   Product(id: "skli3112-123a-as31-34cd-poin2koqs", name: "Коктейль", productDescription: "250 мл", category: "Напитки", price: 320, companyId: 3456121)
]

// Ищем элемент, который не добавлен в productsDatabase
for product in products {
   if let _ = productsDatabase.filter({ $0.id == product.id }).first { // $0.id это id массива productsDatabase || product.id это id массива products
   } else {
       print(product)
       productsDatabase.append(product)
   }
}

print(productsDatabase)


// На самом деле, похожие задачи можно решать по-разному. Например, сейчас у нас есть структура Person, у которой из свойств только возраст. И есть массив людей, чей возраст также указан. При помощи фильтра мы можем выбрать людей, чей возраст нас удовлетворяет для каких-либо целей: например, для участия в соревнованиях ;)
struct Person {
    var age: Int
}
 
let people = [
    Person(age: 22),
    Person(age: 41),
    Person(age: 23),
    Person(age: 30)]
 
let peopleYoungerThan30 = people.filter { $0.age < 30 }
 
print(peopleYoungerThan30) // [Person(age: 22), Person(age: 23)]
// То есть метод filter() мы можем успешно использовать, чтобы создать новый массив, содержащий элементы последовательности, которые удовлетворяют заданному условию, которое может быть представлено как замыкание.


// MARK: 3. reduce
// С помощью reduce мы превращаем несколько элементов в новый объект. Метод reduce можно вызывать и для других типов, не только для массива. Кстати, хотим отметить, что если мы используем reduce, то нам возвращается единичное значение, а не модифицированный массив!
// Метод reduce основывается на функциональном программировании, и его можно встретить в других языках. Это может быть fold в Kotlin или Rust, либо inject в Ruby. Чтобы ещё больше все усложнить (хо-хо), Swift предлагает два варианта метода reduce, поэтому вам нужно будет решить, какой из них выбрать для каждого случая. Давайте рассмотрим оба варианта.

// Используйте reduce чтобы сгруппировать все элементы коллекции в одно результирующее значение. Метод reduce имеет два параметра: начальное значение и функцию(замыкание) группировки. К примеру, мы хотим сложить все элементы массива и прибавить к начальному значению 10.0:

let items = [2.0, 4.0, 5.0, 7.0]
let total = items.reduce(10.0, +) // 28.0 // Начальное значение здесь для гибкости, вы можете использовать 0 и получить просто сумму всех элементов коллекции.
10 + 2 + 4 + 5 + 7 // 28.0

// Пример
let codes = ["abc", "def", "xyz"]
let names = codes.reduce("", +) // abcdefxyz
// Можно использовать другой формат reduce, записывая комбинирующее замыкание в скобках (например, если нужно комбинировать параметры объекта):

// Пример
let names = ["alan","brian","charlie"]
let csv = names.reduce("===") { text, name in "\(text),\(name)" }
print(csv) // "===,alan,brian,charlie"

// Пример
// Мы сначала отфильтровали массив элементов, оставив там числа большие или равные 7, а далее сложили их, используя reduce.
let marks = [4, 5, 8, 2, 9, 7]
let totalPass = marks.filter { $0 >= 7 }.reduce(0, +) // 24

// Пример
// Мы нашли чётные числа при помощи filter, а затем, при помощи map получили их квадраты (квадраты чётных чисел массива).
let numbers = [20, 17, 35, 4, 12]
let evenSquares = numbers.filter { $0 % 2 == 0 }.map { $0 * $0 } // [400, 16, 144]

// В следующий раз, когда решите пробежаться по элементам коллекции в цикле, проверьте, можно ли использовать map/filter/reduce:
// map возвращает массив, который получился в результате применения преобразования к каждому из элементов исходного массива
// filter возвращает массив, который содержит только те элементы, которые удовлетворяют условию фильтрации
// reduce возвращает единичное значение, рассчитанное в результате группирования всех элементов коллекции в один с помощью какой-то операции(например + или *), а также использования начального значения.


// MARK: 4. prefix
// Ещё один способ фильтрации представляет метод prefix(). Он возвращает отфильтрованный массив, при этом он перебирает подряд все элементы, пока условие возвращает true. Условие задается с помощью параметра while, который представляет функцию, возвращающую значение Bool.
// Мы идём по порядку по массиву и проверяем: число меньше 6? Если да, то добавляем его в наш новый массив filteredNumbers и идем дальше, как только условие станет ложным и число будет не меньше 6, мы остановимся и на этом всё закончится. Другими словами, пока условие $0 < 6 выполняется, числа будут попадать в наш отфильтрованный массив.

var numbers = [1, -3, 6, 1, -3, 4, 9, 13, 653, 11, 666, 0, -12, -3223]
var filteredNumbers = numbers.prefix(while: { $0 < 6 })
print(filteredNumbers) // [1, -3]

// Метод drop(), наоборот, удалил элементы 1, -3, пока было условие < 6 затем прекратил выполняться
var numbers = [1, -3, 6, 1, -3, 4, 9, 13, 653, 11, 666, 0, -12, -3223]
var filteredNumbers = numbers.drop(while: { $0 < 6 }) // Удалить (пока < 6 true)
print(filteredNumbers) // [6, 1, -3, 4, 9, 13, 653, 11, 666, 0, -12, -3223]


// MARK: 4. sort
// Для сортировки массива применяется метод sort:

var numbers = [1, 3, 6, 1, 3, 4, 9, 13, 653, 11, 666, 0, -12, 3223]
numbers.sort()
numbers // [-12, 0, 1, 1, 3, 3, 4, 6, 9, 11, 13, 653, 666, 3223]
 
// Если метод sort сортирует исходный массив, то метод sorted() возвращает новый отсортированный массив, никак не изменяя старый:
numbers.sorted() // [-12, 0, 1, 1, 3, 3, 4, 6, 9, 11, 13, 653, 666, 3223]
numbers              // [1, 3, 6, 1, 3, 4, 9, 13, 653, 11, 666, 0, -12, 3223]
 
// Обе функции принимают параметр by, который задает принцип сортировки. Он представляет функцию, которая принимает два параметра. Оба параметра представляют тип элементов массива. На выходе функция возвращает объект Bool. Если это значение равно true, то первое значение ставится до второго, если false — то после.
print(numbers.sorted(by: { $0 > $1 })) // [3223, 666, 653, 13, 11, 9, 6, 4, 3, 3, 1, 1, 0, -12]
// Помните, как мы упрощали методы в предыдущем юните? Давайте сделаем здесь точно так же:
print(numbers.sorted(by: > ))
